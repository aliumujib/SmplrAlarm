package de.coldtea.smplr.smplralarm.apis

import android.app.PendingIntent
import android.content.Context
import de.coldtea.smplr.smplralarm.SmplrAlarmEnvironment
import de.coldtea.smplr.smplralarm.models.AlarmDefinition
import de.coldtea.smplr.smplralarm.models.AlarmIdGenerator
import de.coldtea.smplr.smplralarm.models.AlarmScheduler
import de.coldtea.smplr.smplralarm.models.AlarmStore
import de.coldtea.smplr.smplralarm.models.DefaultAlarmIdGenerator
import de.coldtea.smplr.smplralarm.models.DefaultSmplrAlarmLogger
import de.coldtea.smplr.smplralarm.models.NotificationChannelItem
import de.coldtea.smplr.smplralarm.models.NotificationConfig
import de.coldtea.smplr.smplralarm.models.NotificationItem
import de.coldtea.smplr.smplralarm.models.NotificationTargetDescriptor
import de.coldtea.smplr.smplralarm.models.SmplrAlarmLogger
import de.coldtea.smplr.smplralarm.models.SmplrAlarmLoggerHolder
import de.coldtea.smplr.smplralarm.models.SmplrAlarmReceiverObjects.Companion.SMPLR_ALARM_RECEIVER_INTENT_ID
import de.coldtea.smplr.smplralarm.models.WeekDays
import de.coldtea.smplr.smplralarm.receivers.AlarmReceiver
import de.coldtea.smplr.smplralarm.repository.RoomAlarmStore
import de.coldtea.smplr.smplralarm.services.AlarmSchedulerImpl
import de.coldtea.smplr.smplralarm.services.AlarmService

/**
 * Created by [Yasar Naci Gündüz](https://github.com/ColdTea-Projects).
 */
class SmplrAlarmAPI {

    private val store: AlarmStore
    private val scheduler: AlarmScheduler
    private val idGenerator: AlarmIdGenerator
    private val logger: SmplrAlarmLogger
    private val context: Context

    private var hour = -1
    private var min = -1
    private var second: Int = 0
    private var millis: Int = 0
    private var weekdays: List<WeekDays> = listOf()
    private var isActive: Boolean = true

    // The request code for the current operation. If not explicitly
    // provided by the caller via the DSL, it will be generated by the
    // configured AlarmIdGenerator.
    private var requestCode = -1

    private var notificationChannel: NotificationChannelItem? = null
    private var notification: NotificationItem? = null

    // Optional activation targets, represented as stable descriptors rather
    // than raw Intents so they can be serialized if needed.
    private var contentTarget: NotificationTargetDescriptor? = null
    private var fullScreenTarget: NotificationTargetDescriptor? = null
    private var alarmReceivedTarget: NotificationTargetDescriptor? = null

    private val alarmService by lazy { AlarmService(context) }

    private var infoPairs: List<Pair<String, String>>? = null

    private val isAlarmValid: Boolean
        get() {
            // When both hour and min are left at their default (-1), we
            // treat this as "no-op" for update flows and consider it
            // logically valid. Log this explicitly for debugging.
            if (hour == -1 && min == -1) {
                logger.v("isAlarmValid: hour and min are both -1; treating as valid (no-op time update)")
                return true
            }

            val isHourValid = hour in 0..23
            val isMinValid = min in 0..59
            val valid = isHourValid && isMinValid

            if (!valid) {
                logger.e(
                    "isAlarmValid: INVALID time configuration: hour=$hour (valid=$isHourValid), " +
                        "min=$min (valid=$isMinValid)"
                )
            } else {
                logger.v("isAlarmValid: valid time configuration: hour=$hour, min=$min")
            }

            return valid
        }


    /**
     * Convenience constructor that resolves all dependencies from the
     * global [SmplrAlarmEnvironment]. This is the preferred entry point
     * for most callers and is what the top-level DSL functions use.
     */
    constructor(context: Context) : this(
        context = context,
        store = SmplrAlarmEnvironment.current(context).storeFactory(context),
        idGenerator = SmplrAlarmEnvironment.current(context).idGenerator,
        logger = SmplrAlarmEnvironment.current(context).logger,
        scheduler = SmplrAlarmEnvironment.current(context)
            .schedulerFactory(context),
    )

    /**
     * Constructor that accepts the abstraction layer types directly. This
     * remains available for advanced callers that want full control without
     * going through [SmplrAlarmEnvironment].
     */
    constructor(
        context: Context,
        store: AlarmStore = RoomAlarmStore(context),
        idGenerator: AlarmIdGenerator = DefaultAlarmIdGenerator,
        logger: SmplrAlarmLogger = DefaultSmplrAlarmLogger,
        scheduler: AlarmScheduler = AlarmSchedulerImpl(AlarmService(context), store),
    ) {
        this.context = context
        this.store = store
        this.scheduler = scheduler
        this.idGenerator = idGenerator
        this.logger = logger
        SmplrAlarmLoggerHolder.logger = logger
    }

    fun hour(hour: () -> Int) {
        this.hour = hour()
    }

    fun min(min: () -> Int) {
        this.min = min()
    }

    fun second(second: () -> Int) {
        this.second = second()
    }

    fun millis(millis: () -> Int) {
        this.millis = millis()
    }

    fun requestCode(requestCode: () -> Int) {
        this.requestCode = requestCode()
    }

    fun notificationChannel(notificationChannel: () -> NotificationChannelItem) {
        this.notificationChannel = notificationChannel()
    }

    fun notification(notification: () -> NotificationItem) {
        this.notification = notification()
    }

    fun contentTarget(target: () -> NotificationTargetDescriptor) {
        this.contentTarget = target()
    }

    fun fullScreenTarget(target: () -> NotificationTargetDescriptor) {
        this.fullScreenTarget = target()
    }

    fun alarmReceivedTarget(target: () -> NotificationTargetDescriptor) {
        this.alarmReceivedTarget = target()
    }

    fun weekdays(lambda: WeekDaysAPI.() -> Unit) {
        weekdays = WeekDaysAPI().apply(lambda).getWeekDays()
    }

    fun isActive(isActive: () -> Boolean) {
        this.isActive = isActive()
    }

    fun infoPairs(infoPairs: () -> List<Pair<String, String>>) {
        this.infoPairs = infoPairs()
    }

    internal suspend fun setAlarm(): Int {
        if (isAlarmValid.not()) {
            throw IllegalArgumentException("updateRepeatingAlarm: Your time setup is not valid, please pick a valid time! ")
        }

        if (notification != null && notificationChannel == null) {
            throw IllegalStateException("SmplrAlarm: notificationChannel{} must be provided when setting a notification{}.")
        }

        val finalRequestCode = if (requestCode == -1) {
            idGenerator.generateId()
        } else {
            requestCode
        }
        requestCode = finalRequestCode
        logger.v("setAlarm: $requestCode -- $hour:$min")

        val definition = AlarmDefinition(
            id = finalRequestCode,
            hour = hour,
            minute = min,
            second = second,
            weekdays = weekdays,
            isActive = true,
            nextTriggerTime = null,
            metadata = infoPairs?.toMap().orEmpty(),
            notificationConfig = NotificationConfig(
                channel = notificationChannel,
                notification = notification,
                contentTarget = contentTarget,
                fullScreenTarget = fullScreenTarget,
                alarmReceivedTarget = alarmReceivedTarget,
            ),
        )

        store.insert(definition)

        scheduler.schedule(finalRequestCode, hour, min, second, weekdays)

        alarmService.setAlarm(
            finalRequestCode,
            hour,
            min,
            weekdays,
            second = second,
            millis = millis
        )

        return finalRequestCode
    }

    internal suspend fun renewMissingAlarms() {
        val all = store.getAll()
        all.filter { it.isActive && !alarmService.alarmExist(it.id) }
            .forEach { definition ->
                scheduler.renew(definition)
            }
    }

    internal suspend fun updateAlarm() {
        if (requestCode == -1) {
            throw IllegalArgumentException("updateRepeatingAlarm: Your requestCode, please supply a valid code")
        }

        if (isAlarmValid.not()) {
            throw IllegalArgumentException("updateRepeatingAlarm: Your time setup is not valid, please pick a valid time! ")
        }

        if (notification != null && notificationChannel == null) {
            throw IllegalStateException("SmplrAlarm: notificationChannel{} must be provided when updating a notification{}.")
        }

        alarmService.cancelAlarm(requestCode)
        val updatedActivation = isActive

        val current = store.get(requestCode)
            ?: throw IllegalArgumentException("Alarm with request code $requestCode not found")

        val updatedHour = if (hour == -1) current.hour else hour
        val updatedMinute = if (min == -1) current.minute else min

        val updated = current.copy(
            hour = updatedHour,
            minute = updatedMinute,
            weekdays = weekdays.ifEmpty { current.weekdays },
            isActive = updatedActivation,
            metadata = infoPairs?.toMap() ?: current.metadata,
        )

        store.update(updated)

        if (updatedActivation) {
            scheduler.schedule(
                id = updated.id,
                hour = updated.hour,
                minute = updated.minute,
                second = updated.second,
                weekDays = updated.weekdays,
            )
        } else {
            scheduler.cancel(updated.id)
        }
    }

    internal suspend fun removeAlarm() {
        if (requestCode == -1) {
            throw IllegalArgumentException("updateRepeatingAlarm: Your requestCode, please supply a valid code")
        }

        alarmService.cancelAlarm(requestCode)

        store.delete(requestCode)
        scheduler.cancel(requestCode)
    }

    companion object {

        const val SMPLR_ALARM_NOTIFICATION_ID = "smplr_alarm_notification_id"
        const val SMPLR_ALARM_REQUEST_ID = "smplr_alarm_request_id"

        fun getAlarmIntent(requestCode: Int, context: Context) = PendingIntent.getBroadcast(
            context,
            requestCode,
            AlarmReceiver.build(context).putExtra(SMPLR_ALARM_RECEIVER_INTENT_ID, requestCode),
            PendingIntent.FLAG_NO_CREATE or PendingIntent.FLAG_IMMUTABLE
        )

    }
}
