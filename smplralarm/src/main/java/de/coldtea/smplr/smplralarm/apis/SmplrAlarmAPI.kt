package de.coldtea.smplr.smplralarm.apis

import android.app.PendingIntent
import android.content.Context
import android.content.Intent
import de.coldtea.smplr.smplralarm.models.NotificationChannelItem
import de.coldtea.smplr.smplralarm.models.NotificationItem
import de.coldtea.smplr.smplralarm.models.AlarmStore
import de.coldtea.smplr.smplralarm.models.AlarmScheduler
import de.coldtea.smplr.smplralarm.models.AlarmListObserver
import de.coldtea.smplr.smplralarm.models.AlarmIdGenerator
import de.coldtea.smplr.smplralarm.models.DefaultAlarmIdGenerator
import de.coldtea.smplr.smplralarm.models.AlarmDefinition
import de.coldtea.smplr.smplralarm.models.NotificationConfig
import de.coldtea.smplr.smplralarm.models.NotificationTargetDescriptor
import de.coldtea.smplr.smplralarm.models.SmplrAlarmLogger
import de.coldtea.smplr.smplralarm.models.DefaultSmplrAlarmLogger
import de.coldtea.smplr.smplralarm.models.SmplrAlarmLoggerHolder
import de.coldtea.smplr.smplralarm.models.WeekDays
import de.coldtea.smplr.smplralarm.receivers.AlarmReceiver
import de.coldtea.smplr.smplralarm.receivers.SmplrAlarmReceiverObjects.Companion.SMPLR_ALARM_RECEIVER_INTENT_ID
import de.coldtea.smplr.smplralarm.services.AlarmService
import de.coldtea.smplr.smplralarm.services.AlarmSchedulerImpl
import de.coldtea.smplr.smplralarm.repository.RoomAlarmStore
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import de.coldtea.smplr.smplralarm.models.launchIo
import kotlin.math.absoluteValue

/**
 * Created by [Yasar Naci Gündüz](https://github.com/ColdTea-Projects).
 */
class SmplrAlarmAPI(val context: Context) {

    /**
     * New constructor that accepts the abstraction layer types introduced in
     * the refactor plan. Callers can override the default store/scheduler
     * with their own implementations.
     */
    constructor(
        context: Context,
        store: AlarmStore,
        scheduler: AlarmScheduler,
        observer: AlarmListObserver? = null,
        idGenerator: AlarmIdGenerator = DefaultAlarmIdGenerator,
        logger: SmplrAlarmLogger = DefaultSmplrAlarmLogger,
    ) : this(context) {
        this.store = store
        this.scheduler = scheduler
        this.observer = observer
        this.idGenerator = idGenerator
        this.logger = logger
        SmplrAlarmLoggerHolder.logger = logger
    }

    //region properties

    // New abstraction layer fields.
    private var store: AlarmStore = RoomAlarmStore(context)
    private var scheduler: AlarmScheduler = AlarmSchedulerImpl(AlarmService(context), store)
    private var observer: AlarmListObserver? = null
    private var idGenerator: AlarmIdGenerator = DefaultAlarmIdGenerator
    private var logger: SmplrAlarmLogger = DefaultSmplrAlarmLogger

    private var hour = -1
    private var min = -1
    private var second: Int = 0
    private var millis: Int = 0
    private var weekdays: List<WeekDays> = listOf()
    private var isActive: Boolean = true

    // The request code for the current operation. If not explicitly
    // provided by the caller via the DSL, it will be generated by the
    // configured AlarmIdGenerator.
    private var requestCode = -1

    private var notificationChannel: NotificationChannelItem? = null
    private var notification: NotificationItem? = null

    // Optional activation targets, represented as stable descriptors rather
    // than raw Intents so they can be serialized if needed.
    private var contentTarget: NotificationTargetDescriptor? = null
    private var fullScreenTarget: NotificationTargetDescriptor? = null
    private var alarmReceivedTarget: NotificationTargetDescriptor? = null

    private val alarmService by lazy { AlarmService(context) }

    private var infoPairs: List<Pair<String, String>>? = null

    private val isAlarmValid: Boolean
        get() =
            if (hour == -1 && min == -1) true
        else hour > -1 && hour < 24 && min > -1 && min < 60

    //endregion

    // region DSL setters
    fun hour(hour: () -> Int) {
        this.hour = hour()
    }

    fun min(min: () -> Int) {
        this.min = min()
    }

    fun second(second: () -> Int) {
        this.second = second()
    }

    fun millis(millis: () -> Int) {
        this.millis = millis()
    }

    fun requestCode(requestCode: () -> Int) {
        this.requestCode = requestCode()
    }

    fun contentIntent(contentIntent: () -> Intent) {
        val intent = contentIntent()
        val component = intent.component ?: return
        contentTarget = NotificationTargetDescriptor.ScreenTarget(
            packageName = component.packageName,
            activityClassName = component.className,
            action = intent.action,
            extras = intent.extrasToMap(),
        )
    }

    fun receiverIntent(receiverIntent: () -> Intent) {
        val intent = receiverIntent()
        val component = intent.component ?: return
        fullScreenTarget = NotificationTargetDescriptor.ScreenTarget(
            packageName = component.packageName,
            activityClassName = component.className,
            action = intent.action,
            extras = intent.extrasToMap(),
        )
    }

    fun alarmReceivedIntent(alarmReceivedIntent: () -> Intent) {
        val intent = alarmReceivedIntent()
        val component = intent.component ?: return
        alarmReceivedTarget = NotificationTargetDescriptor.BroadcastTarget(
            packageName = component.packageName,
            receiverClassName = component.className,
            action = intent.action,
            extras = intent.extrasToMap(),
        )
    }

    fun notificationChannel(notificationChannel: () -> NotificationChannelItem) {
        this.notificationChannel = notificationChannel()
    }

    fun notification(notification: () -> NotificationItem) {
        this.notification = notification()
    }

    fun contentTarget(target: () -> NotificationTargetDescriptor) {
        this.contentTarget = target()
    }

    fun fullScreenTarget(target: () -> NotificationTargetDescriptor) {
        this.fullScreenTarget = target()
    }

    fun alarmReceivedTarget(target: () -> NotificationTargetDescriptor) {
        this.alarmReceivedTarget = target()
    }

    fun weekdays(lambda: WeekDaysAPI.() -> Unit) {
        weekdays = WeekDaysAPI().apply(lambda).getWeekDays()
    }

    fun isActive(isActive: () -> Boolean) {
        this.isActive = isActive()
    }

    fun infoPairs(infoPairs: () -> List<Pair<String, String>>) {
        this.infoPairs = infoPairs()
    }

    // endregion

    // region functionality

    internal fun setAlarm(): Int {
        if (isAlarmValid.not()) {
            logger.w("updateRepeatingAlarm: Your time setup is not valid, please pick a valid time! ")
            return -1
        }

        // Determine the request code for this operation. If the caller
        // provided one via the DSL, respect it; otherwise generate a new
        // code via the injected AlarmIdGenerator.
        val finalRequestCode = if (requestCode == -1) {
            idGenerator.generateId()
        } else {
            requestCode
        }
        requestCode = finalRequestCode
        logger.v("setAlarm: $requestCode -- $hour:$min")

        // Build new AlarmDefinition for the opinionated storage path.
        val definition = AlarmDefinition(
            id = finalRequestCode,
            hour = hour,
            minute = min,
            second = second,
            weekdays = weekdays,
            isActive = true,
            nextTriggerTime = null,
            metadata = infoPairs?.toMap().orEmpty(),
            notificationConfig = NotificationConfig(
                channel = notificationChannel,
                notification = notification,
                contentTarget = contentTarget,
                fullScreenTarget = fullScreenTarget,
                alarmReceivedTarget = alarmReceivedTarget,
            ),
        )

        launchIo {
            // New path: store definition in the dedicated AlarmStore.
            store.insert(definition)
            observer?.onAlarmListChanged(store.getAll())
        }

        // New path: schedule via AlarmScheduler abstraction.
        scheduler.schedule(finalRequestCode, hour, min, second, weekdays)

        // Legacy path: keep current AlarmService behavior.
        alarmService.setAlarm(finalRequestCode, hour, min, weekdays, second = second, millis = millis)

        return finalRequestCode
    }

    internal fun renewMissingAlarms() = launchIo {
        runCatching {
            val all = store.getAll()
            all.filter { it.isActive && !alarmService.alarmExist(it.id) }
                .forEach { definition ->
                    scheduler.renew(definition)
                }
        }.onFailure { throwable ->
            logger.e("renewMissingAlarms failed: ${throwable.message}", throwable)
        }
    }

    internal fun updateAlarm() {
        if (requestCode == -1) return
        if (isAlarmValid.not()) {
            logger.w("updateRepeatingAlarm: Your time setup is not valid, please pick a valid time! ")
            return
        }

        alarmService.cancelAlarm(requestCode)
        val updatedActivation = isActive

        launchIo {
            runCatching {
                val current = store.get(requestCode) ?: return@launchIo

                val updatedHour = if (hour == -1) current.hour else hour
                val updatedMinute = if (min == -1) current.minute else min

                val updated = current.copy(
                    hour = updatedHour,
                    minute = updatedMinute,
                    weekdays = weekdays.ifEmpty { current.weekdays },
                    isActive = updatedActivation,
                    metadata = infoPairs?.toMap() ?: current.metadata,
                )

                store.update(updated)

                if (updatedActivation) {
                    scheduler.schedule(
                        id = updated.id,
                        hour = updated.hour,
                        minute = updated.minute,
                        second = updated.second,
                        weekDays = updated.weekdays,
                    )
                } else {
                    scheduler.cancel(updated.id)
                }
            }.onFailure { throwable ->
                logger.e("updateRepeatingAlarm failed: ${throwable.message}", throwable)
            }
        }
    }

    internal fun removeAlarm() {
        alarmService.cancelAlarm(requestCode)

        CoroutineScope(Dispatchers.IO).launch {
            runCatching {
                store.delete(requestCode)
                scheduler.cancel(requestCode)
            }.onFailure { throwable ->
                logger.e("removeAlarm failed: ${throwable.message}", throwable)
            }
        }
    }

    // endregion

    private fun Intent.extrasToMap(): Map<String, String> {
        val extrasBundle = extras ?: return emptyMap()
        val result = mutableMapOf<String, String>()
        for (key in extrasBundle.keySet()) {
            val value = extrasBundle.get(key)
            if (value != null) {
                result[key] = value.toString()
            }
        }
        return result
    }

    companion object {

        const val SMPLR_ALARM_NOTIFICATION_ID = "smplr_alarm_notification_id"
        const val SMPLR_ALARM_REQUEST_ID = "smplr_alarm_request_id"

        fun getAlarmIntent(requestCode: Int, context: Context) = PendingIntent.getBroadcast(
            context,
            requestCode,
            AlarmReceiver.build(context).putExtra(SMPLR_ALARM_RECEIVER_INTENT_ID, requestCode),
            PendingIntent.FLAG_NO_CREATE or PendingIntent.FLAG_IMMUTABLE
        )

    }
}
